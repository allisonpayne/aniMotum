##' @title Filter `sim_fit` simulations
##' 
##' @description This function calculates the similarity between the simulations
##' generated by `sim_fit` and the SSM-estimated path from the `ssm` fit,
##' and returns a `sim_fit` object containing the most similar tracks based on
##' a user specified quantile. In this context, similarity is the sum of 
##' normalised differences in distance and bearing between the SSM-estimated path
##' and the simulated paths. 
##' 
##' @param trs a `sim_fit` object
##' @param keep the quantile of flag values to retain
##' @param flag the similarity flag method (see details)
##' 
##' @details
##' * `flag = 1` will use an index based on Hazen (2017)
##' * `flag = 2` (the default) will use a custom index
##' 
##' @return a `sim_fit` object containing the filtered paths
##' 
##' 
##' @examples
##' ## fit crw model to Argos LS data
##' fit <- fit_ssm(ellie, model = "crw", time.step = 72)
##' 
##' set.seed(pi)
##' ## generate 5 simulated paths from ssm fit
##' trs <- sim_fit(fit, what = "predicted", reps = 5)
##' 
##' ## filter simulations and keep paths in top 40% of flag values
##' trs_f <- sim_filter(trs, keep = 0.4, flag = 2)
##' 
##' ## compare unfiltered and filtered simulated paths
##' \donttest{
##' plot(trs) | plot(trs_f)
##' }
##' 
##' @references Hazen et al. (2017) WhaleWatch: a dynamic management tool for 
##' predicting blue whale density in the California Current J. Appl. Ecol. 54: 1415-1428
##' 
##' @importFrom dplyr group_by ungroup select "%>%" filter bind_rows mutate
##' @importFrom dplyr first
##' @importFrom tidyr nest unnest
##' @importFrom traipse track_distance_to track_bearing_to
##' @importFrom stats quantile
##' @export
##' @md

sim_filter <- function(trs, keep = .25, flag = 2){

  stopifnot("trs must be a `sim_fit` object" = inherits(trs, "sim_fit"))
  
  # filter based on similarity to original path
  # apply the similarity flag function to each simulated track
  # unnest the sim_fit object to extract the simulations
  trs_df <- trs %>% unnest(cols = c(sims))
  
  ## append distance (km), bearing along tracks via traipse fn's
  trs_df <- trs_df %>%
    group_by(rep) %>%
    mutate(dist = track_distance_to(lon, lat, first(lon), first(lat)) / 1000) %>%
    mutate(bear = track_bearing_to(lon, lat, first(lon), first(lat)) + 180) %>%
    ungroup()
  
  trs_lst <- split(trs_df, trs_df$id)
  flg <- lapply(trs_lst, function(x) {
    sapply(split(x, x$rep)[-1], function(.x) {
      similarity_flag(
        track = x %>% filter(rep == 0),
        sim_track = .x,
        flag = flag,
        cpf = ifelse("cpf" %in% class(trs), TRUE, FALSE)
      )
    }) 
  })
  
  k.idx <- lapply(flg, function(x) {
    which(abs(x) < quantile(abs(x), keep))
  })

  # filter based on user defined 'keep'
  # flag values can be positive or negative but will be centered around 0 (perfect match)
  # select only those tracks that have a flag value in the top 'keep' of flag values
  foo <- lapply(1:length(trs_lst), function(i) {
    rep0 <- split(trs_lst[[i]], trs_lst[[i]]$rep)[[1]]
    tmp <- split(trs_lst[[i]], trs_lst[[i]]$rep)[-1]
    reps <- tmp[k.idx[[i]]] %>% bind_rows()
    rbind(rep0, reps)
  }) %>%
    bind_rows() %>%
    select(-dist, -bear)
  
  # format for foieGras output
  trs_filt <- foo %>% nest(sims = c(rep, date, lon, lat, x, y))
  class(trs_filt) <- append(class(trs)[1:2], class(trs_filt))
  
  return(trs_filt) 
}
